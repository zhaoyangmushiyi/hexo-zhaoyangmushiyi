---
title: Java面试清单(三、多线程)
date: 2019-04-07 15:25:54
tags:
    - Java
categories:
    - Java
---
## 并行和并发有什么区别？
并发是多个事件在同一时间段执行，而并行是多个事件在同一时间点执行  
打个比方。并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。  
<!-- more -->
## 线程和进程的区别？
1.因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。  
2.体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。  
3.属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。  
4.线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；  
5.线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程  

## 守护线程是什么？
所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。  
守护线程和用户线程的没啥本质的区别：唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。  
将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：  
(1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。  
(2) 在Daemon线程中产生的新线程也是Daemon的。  
(3) 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。  

## 创建线程有哪几种方式？
1.通过继承Thread类创建线程类  
2.实现Runnable接口方式创建线程类  
3.使用Callable和Future创建线程  

## 说一下 runnable 和 callable 有什么区别？
1、Runnable 比 Callable 古老一点, 前者源于 JDK1.0, 后者源于 Java 5.  
2、Runnable 接口用 run() 方法来描述一个任务(task), 而 Callable 使用 call().  
3、run()方法不会返回结果, 因为它的返回类型是 void. 而 Callable 是个 支持泛型的接口, 当要实现(implement)一个Callable接口的时候, 就会提供一个返回值类型.  
4、run()方法不会抛出 checked exception 异常, 而 call() 方法可以  

## 线程有哪些状态？
New (新创建)  
　　当用new操作符创建一个线程时，如new Thread(r)，该线程还没有开始运行。这意外这它的状态是new。此时程序还没有开始运行线程中的代码，在线程运行之前还有一些基础工作要做。  
Runnable (可运行/就绪)  
　　一旦处于新状态的线程调用start方法(如图中的1所示)，线程就处于Runnable状态。  
　　处于Runnable状态的线程还未运行run()方法的代码，只有在获得CPU时间片才开始运行。  
Running (运行中)  
　　当线程获得CPU时间片，线程就进入Running状态(如图中的2所示)。  
处于Running状态的线程有可能在运行中CPU时间片用完，而run方法没运行完，线程就又进入Runnable状态。  
　　通常情况下，运行中的线程一直处于Running与Runnable交替转换的过程中。  
Blocked (等待/阻塞/睡眠)  
　　当线程在Running状态中，遇到阻塞等待锁、等待用户输入、调用sleep()方法、调用join等待其他线程情况，会导致线程进入阻塞状态(Blocked)。  
　　处于阻塞状态的线程，在阻塞等待结束之后，会进入Runnable状态，等等获得CPU时间片继续运行程序。  
Dead (死亡)  
　　当线程运行完run方法，直接进入死亡状态Dead 。  

## sleep() 和 wait() 有什么区别？
1、（使用限制）使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁，而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁  
2、（使用场景） sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信  
3、（所属类）sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。  
4、（释放锁），wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。  

## notify()和 notifyAll()有什么区别？
首先大家要理解同步锁synchronized 的概念，以及，要知道，wait(),notify(),notifyAll() 这三个方法是对象（Object）的方法。举个例子class Person;Person Ming;现在有一个叫做Ming的对象。被线程A、B、C、D都有调用。A、B、C、D 四个线程都有如下的synchronized语句  
synchronized（Ming）{......}  
首先，小明家有个门，门上有一把锁，小明会给ABCD四个线程每人一个进门许可，有许可的人，谁先抢先进门，就可以把门上锁，别人就没办法进入。等到他办完事之后，出门，打开锁，别人才有办法进入。wait()方法那wait()方法是什么呢，wait方法是如果线程A在房间里面做到一半突然想走，那么执行wait()之后，A就会出门，然后在一个等待区等着，注意，这个时候A已经失去进门许可了，所以，当A出门之后，A已经暂时没资格和BCD竞争了，BCD中的某一个进门之后，重新上锁，办事。另外wait(int s) 中是可以携带参数的，参数的意思是 经过s毫秒之后，A重新获得的进门许可，如果这个时候房间里没人，那么A也可以继续竞争了。  
notify()方法，和notifyAll()方法。  
notify()方法就是 小明重新发一个进门许可给等待区的线程，至于哪个线程能得到许可，就要靠他们竞争了。比如ABCD都进门成功，然后因为某些原因中途出门了（使用了wait()方法），现在ABCD都在等待区，那么，在使用了a.notify()方法之后，ABCD中的一个就能重新获得进门许可（假设B拿到了），如果此时还有一个E也有进门资格，那么B和E就要竞争下一次的进门机会了，如果B竞争成功，那么B就可以进门继续之前没有完成的部分（即a.wait()语句下面的部分）  
而notifyAll()方法呢？顾名思义，就是小明给等待区的所有线程都重新发放了进门许可。  

## 线程的 run()和 start()有什么区别？
tart() :    
它的作用是启动一个新线程。  
通过start()方法来启动的新线程，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。start()不能被重复调用。用start方法来启动线程，真正实现了多线程运行，即无需等待某个线程的run方法体代码执行完毕就直接继续执行下面的代码。这里无需等待run方法执行完毕，即可继续执行下面的代码，即进行了线程切换。  

run() :  
run()就和普通的成员方法一样，可以被重复调用。  
如果直接调用run方法，并不会启动新线程！程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。  
总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。  

总结一下：  
1、tart() 可以启动一个新线程，run()不能  
2、start()不能被重复调用，run()可以  
3、start()中的run代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用run方法必须等待其代码全部执行完才能继续执行下面的代码。  
4、start() 实现了多线程，run()没有实现多线程  

## 创建线程池有哪几种方式？
newSingleThreadExecutor  
创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。  

newFixedThreadPool  
创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。  

newCachedThreadPool  
创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，  
那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。  

newScheduledThreadPool  
创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。  

newSingleThreadScheduleExecutor()  
创建只有一条线程的线程池，他可以在指定延迟后执行任务。  

自定义线程池  
```
public ThreadPooIExecutor(  
int corePoolSize， 
int maximumPoolSize，
long keepAliveTime , 
TimeUnit unit，
BlockingQueue<Runna ble> workQueue, 
ThreadFactory threadFactory,
RejectedExecutionHandler handler) {……}
```

## 线程池都有哪些状态？
线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。  

1、RUNNING  
(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。  
(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！  

2、 SHUTDOWN  
(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。  
(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。  

3、STOP  
(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。  
(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。  

4、TIDYING  
(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。  
(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。  
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。  

5、 TERMINATED  
(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。  
(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED  

## 线程池中 submit()和 execute()方法有什么区别？
execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。——实现Runnable接口  
submit(Runnable x) 返回一个future。可以用这个future来判断任务是否成功完成。——实现Callable接口  

## 在 java 程序中怎么保证多线程的运行安全？
1、互斥同步  
互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。  
在java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码质量，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。  
此外，ReentrantLock也是通过互斥来实现同步。在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性。  
互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。  

2、非阻塞同步  
随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。  
非阻塞的实现CAS（CompareAndSwap）：CAS指令需要有3个操作数，分别是内存地址（在java中理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，CAS指令指令时，当且仅当V处的值符合旧预期值A时，处理器用B更新V处的值，否则它就不执行更新，但是无论是否更新了V处的值，都会返回V的旧值，上述的处理过程是一个原子操作。  

CAS缺点：  
ABA问题：因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。  
ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A-B-A就变成了1A-2B-3C。JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。  

3、无需同步方案  
要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性，因此会有一些代码天生就是线程安全的。  

1）可重入代码  
可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。  
可重入代码的特点是不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数中传入、不调用 非可重入的方法等。  
（类比：synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁）  

2）线程本地存储 ThreadLocal  
如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。  
符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典的Web交互模型中的“一个请求对应一个服务器线程（Thread-per-Request）”的处理方式，这种处理方式的广泛应用使得很多Web服务器应用都可以使用线程本地存储来解决线程安全问题。  

## 多线程锁的升级原理是什么？


## 什么是死锁？
如果一组进程中每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。  
举例来说：有两个进程A和B,A持有资源a等待b资源，B持有资源b等待a资源，两个进程都在等待另一个资源的同时不释放资源，就形成死锁。  
死锁的发生必须具备以下四个必要条件。  
1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。  
2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。  
3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。  
4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。  

## 怎么防止死锁？
处理死锁的思路如下：  
预防死锁：  
破坏四个必要件中的一个或多个来预防死锁  

避免死锁：  
在资源动态分配的过程中，用某种方式防止系统进入不安全的状态。  

检测死锁：  
运行时产生死锁，及时发现思索，将程序解脱出来。  

解除死锁：  
发生死锁后，撤销进程，回收资源，分配给正在阻塞状态的进程  

预防死锁的办法：  
破坏请求和保持条件：  
1.一次性的申请所有资源。之后不在申请资源，如果不满足资源条件则得不到资源分配。  
2.只获得初期资源运行，之后将运行完的资源释放，请求新的资源。  
破坏不可抢占条件：  
当一个进程获得某种不可抢占资源，提出新的资源申请，若不能满足，则释放所有资源，以后需要，再次重新申请。破坏循环等待条件：对资源进行排号，按照序号递增的顺序请求资源。若进程获得序号高的资源想要获取序号低的资源，就需要先释放序号高的资源。  
死锁的解除办法：  
1、抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。  
2、终止（撤销）进程：将一个或多个思索进程终止（撤销），直至打破循环环路，使系统从死锁状态解脱。  

## ThreadLocal 是什么？有哪些使用场景？


## 说一下 synchronized 底层实现原理？


## synchronized 和 volatile 的区别是什么？


## synchronized 和 Lock 有什么区别？
Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。  

Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。  

Synchronized和Lock比较  

Synchronized是关键字，内置语言实现，Lock是接口。  
Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。  
Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。  
Lock可以使用读锁提高多线程读效率。  

## synchronized 和 ReentrantLock 区别是什么？
两者的共同点：  
1）协调多线程对共享对象、变量的访问  
2）可重入，同一线程可以多次获得同一个锁  
3）都保证了可见性和互斥性  
两者的不同点：  
1）ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁  
2）ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性  
3）ReentrantLock是API级别的，synchronized是JVM级别的  
4）ReentrantLock可以实现公平锁  
5）ReentrantLock通过Condition可以绑定多个条件  
6）底层实现不一样 synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略  

## 说一下 atomic 的原理？
