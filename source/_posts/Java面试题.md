---
title: Java面试题
date: 2019-02-28 14:35:37
tags:
    - Java
categories:
    - Java
---
# 面向对象主要的四大特性
## 基础篇
### 基本功
#### 面向对象的特征
##### 抽象
- 忽略一个主题中与当前目标无关的东西,专注的注意与当前目标有关的方面.(就是把现实世界中的某一类东西,提取出来,用程序代码表示,抽象出来的一般叫做类或者接口).抽象并不打算了解全部问题,而是选择其中的一部分,暂时不用部分细节.抽象包括两个方面,一个数据抽象,而是过程抽象.
- 数据抽象 -->表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)
- 过程抽象 -->表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)
<!-- more -->
##### 封装
- 封装就是把过程和数据包围起来,对数据的访问只能通过特定的界面.如私有变量,用set,get方法获取
##### 继承
- 一种联结类的层次模型,并且允许和鼓励类的重用,提供一种明确表达共性的方法.对象的一个新类可以从现有的类中派生,这个过程称为类继承.新类继承了原始类的特性,新类称为原始类的派生类(子类),原始类称为新类的基类(父类).派生类可以从它的父类哪里继承方法和实例变量,并且类可以修改或增加新的方法使之更适合特殊的需要.因此可以说,继承为了重用父类代码,同时为实现多态性作准备.
##### 多态
- 多态是指允许不同类的对象对同一消息做出响应.多态性包括参数化多态性和包含多态性.多态性语言具有灵活/抽象/行为共享/代码共享的优势,很好的解决了应用程序函数同名问题.总的来说,方法的重写,重载与动态链接构成多态性.java引入多态的概念原因之一就是弥补类的单继承带来的功能不足.
- 动态链接 -->对于父类中定义的方法,如果子类中重写了该方法,那么父类类型的引用将调用子类中的这个方法,这就是动态链接.
##### 注意
注意继承与重载:子类与父类的关系,重载方法的调用问题  
子类对象可以直接当成父类对象用,但是反过来就不行.比如:人是父类,学生是人的子类,所以学生对象一定具备人对象的属性,但是人对象就未必具有学生对象的特性.但是子类对象当做父类来用,将失去子类所有特性,只保留与父类同名的属性和方法,此时可以对父类方法进行重写.  
一个类中如果定义了重载的方法,则系统在调用方法时,会根据参数的类型自动选择调用合适的方法  

#### final, finally, finalize 的区别
##### final
final可以用来修饰类，方法和变量（成员变量或局部变量）  
##### finally
finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。（×）    
只有与finally对应的try语句块得到执行的情况下，finally语句块才会执行。  
当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。
##### finalize
finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。 
特殊情况下，需要程序员实现finalize，当对象被回收的时候释放一些资源，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。   
使用finalize还需要注意一个事，调用super.finalize();  
一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。 所以，推荐不要使用finalize()方法，它跟析构函数不一样。  
#### int 和 Integer 有什么区别
①、Integer 是 int 包装类，int 是八大基本数据类型之一（byte,char,short,int,long,float,double,boolean）
②、Integer 是类，默认值为null，int是基本数据类型，默认值为0；
③、Integer 表示的是对象，用一个引用指向这个对象，而int是基本数据类型，直接存储数值。
#### 重载(Overloading)和重写(Overriding)的区别
##### 重载(Overloading)
①、方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。  
②、Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。  
③、重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。  
##### 重写(Overriding)
（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。  
（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。  
（3）子类函数的访问修饰权限不能少于父类的；  
#### 抽象类和接口有什么区别
什么时候使用抽象类和接口

- 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。
- 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
- 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

Java8中的默认方法和静态方法
Oracle已经开始尝试向接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异
#### 说说反射的用途及实现
##### 什么是Java类中的反射？
当程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。我们认为 Java 并不是动态语言，但是它却又一个非常突出的动态相关的机制，俗称：反射。  
通过反射，我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息。  
程序中一般的对象类型都是在编译期就确定下来的，而Java 反射机制可以动态的创建对象并调用其属性，这样对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象即使这个对象在编译期是未知的，反射的核心：是 JVM 在运行时 才动态加载的类或调用方法或属性，他不需要事先（写代码的时候或编译期）知道运行对象是谁。  
Java反射框架提供以下功能：  
 ①、在运行时判断任意一个对象所属的类   
 ②、在运行时构造任意一个类的对象  
 ③、在运行时判断任意一个类所具有的成员变量和方法（通过反射设置可以调用 private）  
 ④、在运行时调用人一个对象的方法  
很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。  
##### 反射的基本运用
以上我们提到了反射可以拟用于判断任意对象所属的类，获得 Class对象，构造人一个对象以及调用一个对象。这里我们介绍一下基本反射功能的事先（反射相关类一般都在 java.lang.relfect包里）。

①、获得 Class 对象  
```（1）、使用 Class类的 forName() 静态方法：
public static Class<?> forName(String className)
……
在JDBC开发中常用此方法加载数据库驱动:
……java
Class.forName(driver)
（2）、直接获取某一个对象的 class，比如：
Class<?> klass = int.class;
Class<?> classInt = Integer.TYPE;
（3）、调用某个对象的getClass() 方法，比如：
StringBuilder str = new StringBuilder("123");
Class<?> klass = str.getClass();
```

②、判断是否为某个类的实例  
一般地，我们用 instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的 isInstance()方法来判断是否为某个类的实例，它是一个 Native 方法：  
```
public native boolean isInstance(Object obj);
```

③、创建实例  
通过反射来生成对象主要有两种方式。  
（1）使用 Class 对象的 newInstance() 方法来创建对象对应类的实例。  
```
Class<?> c  = String.calss;
Object str = c.getInstance();
```
（2）、先通过 Class 对象获取制定的 Constructor 对象，在调用 Constructor 对象的 newInstance() 方法来创建实例。这种方法可以用指定的构造器构造类的实例。  
  ```
  //获取String所对应的Class对象
   Class<?> c = String.class;
  //获取String类带一个String参数的构造器
  Constructor constructor = c.getConstructor(String.class);
  //根据构造器创建实例
  Object obj = constructor.newInstance("23333");
  System.out.println(obj);
```
#### 说说自定义注解的场景及实现
自定义注解会需要元注解，此处先介绍元注解。
##### 元注解：  
java中有四种元注解：@Retention、@Inherited、@Documented、@Target  
@Retention  
注解的保留位置（枚举RetentionPolicy），RetentionPolicy可选值：  
- SOURCE：注解仅存在于源码中，在class字节码文件中不包含
- CLASS：默认的保留策略，注解在class字节码文件中存在，但运行时无法获得
- RUNTIME：注解在class字节码文件中存在，在运行时可以通过反射获取到
@Inherited  
声明子类可以继承此注解，如果一个类A使用此注解，则类A的子类也继承此注解  
@Documented  
声明注解能够被javadoc等识别（下面自定义注解处会有例子做介绍，点击查看）  
@Target  
用来声明注解范围（枚举ElementType），ElementType可选值：  
- TYPE：接口、类、枚举、注解
- FIELD：字段、枚举的常量
- METHOD：方法
- PARAMETER：方法参数
- CONSTRUCTOR：构造函数
- LOCAL_VARIABLE：局部变量
- ANNOTATION_TYPE：注解
- PACKAGE：包
##### 自定义注解介绍
自定义注解使用场景  
- 1.类属性自动赋值。
- 2.验证对象属性完整性。
- 3.代替配置文件功能，像spring基于注解的配置。
- 4.可以生成文档，像java代码注释中的@see,@param等
1和2这个没有做过类似实例，应该是像Hibernate中的使用注解映射Bean对象到数据库一样（此处为个人猜测，如有错误请留言指出），中间有检测和自动赋值。  

自定义注解定义  
定义一个自定义注解（不使用元注解）：
```
public @interface MyAnnotation{}
```
定义一个自定义注解（使用元注解，每个元注解都是可选，非必选）：  
```
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Target({ElementType.FIELD,ElementType.METHOD})
public @interface MyAnnotation1{
    public String name() default "hello";
}
```
注解中可以声明成员方法，声明的成员方法为最终的注解里面的参数，成员方法可以使用default关键字设置默认值。上面的注解使用如：@MyAnnotation1(name=”ddd”)。

自定义注解演示  
新建一个自定义注解：  
```
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Target({ElementType.FIELD,ElementType.METHOD})
@interface MyAnno{
    public String name() default "zhangsan";
    public String email() default "hello@example.com";
}
```
定义一个User类，来使用自定义注解：  
```
class User{
    @MyAnno(name = "zhang")
    private String name;
    @MyAnno(name = "zhang@example.com")
    private String email;
    @MyAnno(name = "sayHelloWorld")
    public String sayHello(){
        return "";
        
        }
    }
```
- @Documented注解的作用  
定义的MyAnno注解中使用了@Documented注解，可以看到User类中sayHello方法的javadoc。
- 通过反射获取注解信息  
下面我们通过反射来演示下获取属性的注解信息和方法的注解信息：
```
Method[] methods = User.class.getMethods();
//Field[] fields = User.class.getFields();
Field[] fields = User.class.getDeclaredFields();
/* 
	getFields：只能访问public属性及继承到的public属性
	getDeclaredFields：只能访问到本类的属性，不能访问继承到的属性
	getMethods：只能访问public方法及继承到的public方法
	getDeclaredMethods：只能访问到本类的方法，不能访问继承到的方法
	getConstructors：只能访问public构造函数及继承到的public构造函数
	getDeclaredConstructors：只能访问到本类的构造函数，不能访问继承到的构造函数
*/
for (Field field : fields) {
	MyAnno annotation = field.getAnnotation(MyAnno.class);
	if(annotation!=null){
		System.out.println("property="+annotation.name());
	} 
} 
for (Method method : methods) {
	MyAnno annotation = method.getAnnotation(MyAnno.class);
	if(annotation!=null){
		System.out.println("sayHello="+annotation.name());
	}
}
```
输出如下：
```
property=zhang
property=zhang@example.com
sayHello=sayHelloWorld
```
#### HTTP 请求的 GET 与 POST 方式的区别
最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。  
GET和POST还有一个重大区别，简单的说：  
GET产生一个TCP数据包；POST产生两个TCP数据包。  
长的说：  
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；  
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）  
#### session 与 cookie 区别
- 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
- 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗;考虑到安全应当使用session。
- 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能;考虑到减轻服务器性能方面，应当使用COOKIE。
- 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
- 5、所以个人建议：  
将登陆信息等重要信息存放为SESSION  
其他信息如果需要保留，可以放在COOKIE中  
#### session 分布式处理
- 1.基于数据库的Session共享
- 2.基于NFS共享文件系统
- 3.基于memcached 的session，如何保证 memcached 本身的高可用性？
- 4.基于resin/tomcat web容器本身的session复制机制
- 5.基于TT/Redis 或 jbosscache 进行 session 共享。
- 6.基于cookie 进行session共享
#### JDBC 流程
第1步：注冊驱动 (仅仅做一次)  
第2步：建立连接(Connection)  
第3步：创建运行SQL的语句(Statement)  
第4步：运行语句  
第5步：处理运行结果(ResultSet)  
第6步：释放资源  
#### MVC 设计思想
一、概念
MVC是model、view、controller的简称。它是一中软件的设计思想，将应用的一个输入、处理、输出按照模型层，视图层，控制层进行分层设计。  
1)模型: 业务逻辑包含了业务数据的加工与处理以及相应的基础服务(为了保证业务逻辑能够正常进行的事务、安全、权限、日志等等的功能模块)  
2)视图:展现模型处理的结果；另外，还要提供相应的操作界面，方便用户使用。  
3)控制器:视图发请求给控制器，由控制器来选择相应的模型来处理；模型返回的结果给控制器，由控制器选择合适的视图。   
二、优缺点
1、低耦合性  
　　前后端分离，更有效率。  
　　视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。
2、高重用性和可适用性  
　　MVC模式允许你使用各种不同样式的视图来访问同一个服务器端的代码。它包括任何WEB（HTTP）浏览器或者无线浏览器（wap），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。例如，很多数据可能用HTML来表示，但是也有可能用WAP来表示，而这些表示所需要的命令是改变视图层的实现方式，而控制层和模型层无需做任何改变。  
3、较低的生命周期成本  
　　MVC使开发和维护用户接口的技术含量降低。  
4、快速的部署  
　　使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。  
5、可维护性  
　　分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。  
6、有利于软件工程化管理  
　　由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化管理程序代码。

缺点：  
　　使用mvc，会增加代码量、相应地也会增加软件开发的成文，设计的难度也会增加。一些小项目，完全可以不用。 
#### equals 与 == 的区别
三、具体用例
1、spring mvc框架
2、jsp+servlet
### 集合
#### List 和 Set 区别
#### List 和 Map 区别
#### ArrayList 与 LinkedList 区别
#### ArrayList 与 Vector 区别
#### HashMap 和 Hashtable 的区别
#### HashSet 和 HashMap 区别
#### HashMap 和 ConcurrentHashMap 的区别
#### HashMap 的工作原理及代码实现
#### ConcurrentHashMap 的工作原理及代码实现

### 线程
#### 创建线程的方式及实现
#### sleep() 、join()、yield()有什么区别
#### 说说 CountDownLatch 原理
#### 说说 CyclicBarrier 原理
#### 说说 Semaphore 原理
#### 说说 Exchanger 原理
#### 说说 CountDownLatch 与 CyclicBarrier 区别
#### ThreadLocal 原理分析
#### 讲讲线程池的实现原理
#### 线程池的几种方式
#### 线程的生命周期

### 锁机制

#### 说说线程安全问题
#### volatile 实现原理
#### synchronize 实现原理
#### synchronized 与 lock 的区别
#### CAS 乐观锁
#### ABA 问题
#### 乐观锁的业务场景及实现方式

## 核心篇

### 数据存储
#### MySQL 索引使用的注意事项
#### 说说反模式设计
#### 说说分库与分表设计
#### 分库与分表带来的分布式困境与应对之策
#### 说说 SQL 优化之道
#### MySQL 遇到的死锁问题
#### 存储引擎的 InnoDB 与 MyISAM
#### 数据库索引的原理
#### 为什么要用 B-tree
#### 聚集索引与非聚集索引的区别
#### limit 20000 加载很慢怎么解决
#### 选择合适的分布式主键方案
#### 选择合适的数据存储方案
#### ObjectId 规则
#### 聊聊 MongoDB 使用场景
#### 倒排索引
#### 聊聊 ElasticSearch 使用场景

### 缓存使用

#### Redis 有哪些类型
#### Redis 内部结构
#### 聊聊 Redis 使用场景
#### Redis 持久化机制
#### Redis 如何实现持久化
#### Redis 集群方案与实现
#### Redis 为什么是单线程的
#### 缓存奔溃
#### 缓存降级
#### 使用缓存的合理性问题

### 消息队列
#### 消息队列的使用场景
#### 消息的重发补偿解决思路
#### 消息的幂等性解决思路
#### 消息的堆积解决思路
#### 自己如何实现消息队列
#### 如何保证消息的有序性

## 框架篇

### Spring
#### BeanFactory 和 ApplicationContext 有什么区别
#### Spring Bean 的生命周期
#### Spring IOC 如何实现
#### 说说 Spring AOP
#### Spring AOP 实现原理
#### 动态代理（cglib 与 JDK）
#### Spring 事务实现方式
#### Spring 事务底层原理
#### 如何自定义注解实现功能
#### Spring MVC 运行流程
#### Spring MVC 启动流程
#### Spring 的单例实现原理
#### Spring 框架中用到了哪些设计模式
#### Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）

### Netty

#### 为什么选择 Netty
#### 说说业务中，Netty 的使用场景
#### 原生的 NIO 在 JDK 1.7 版本存在 epoll bug
#### 什么是TCP 粘包/拆包
#### TCP粘包/拆包的解决办法
#### Netty 线程模型
#### 说说 Netty 的零拷贝
#### Netty 内部执行流程
#### Netty 重连实现

## 微服务篇

### 微服务
#### 前后端分离是如何做的
#### 微服务哪些框架
#### 你怎么理解 RPC 框架
#### 说说 RPC 的实现原理
#### 说说 Dubbo 的实现原理
#### 你怎么理解 RESTful
#### 说说如何设计一个良好的 API
#### 如何理解 RESTful API 的幂等性
#### 如何保证接口的幂等性
#### 说说 CAP 定理、 BASE 理论
#### 怎么考虑数据一致性问题
#### 说说最终一致性的实现方案
#### 你怎么看待微服务
#### 微服务与 SOA 的区别
#### 如何拆分服务
#### 微服务如何进行数据库管理
#### 如何应对微服务的链式调用异常
#### 对于快速追踪与定位问题
#### 微服务的安全

### 分布式
#### 谈谈业务中使用分布式的场景
#### Session 分布式方案
#### 分布式锁的场景
#### 分布是锁的实现方案
#### 分布式事务
#### 集群与负载均衡的算法与实现
#### 说说分库与分表设计
#### 分库与分表带来的分布式困境与应对之策

## 安全&性能

### 安全问题

#### 安全要素与 STRIDE 威胁
#### 防范常见的 Web 攻击
#### 服务端通信安全攻防
#### HTTPS 原理剖析
#### HTTPS 降级攻击
#### 授权与认证
#### 基于角色的访问控制
#### 基于数据的访问控制

### 性能优化
#### 性能指标有哪些
#### 如何发现性能瓶颈
#### 性能调优的常见手段
#### 说说你在项目中如何进行性能调优

## 工程篇

### 需求分析
#### 你如何对需求原型进行理解和拆分
#### 说说你对功能性需求的理解
#### 说说你对非功能性需求的理解
#### 你针对产品提出哪些交互和改进意见
#### 你如何理解用户痛点

### 设计能力
#### 说说你在项目中使用过的 UML 图
#### 你如何考虑组件化
#### 你如何考虑服务化
#### 你如何进行领域建模
#### 你如何划分领域边界
#### 说说你项目中的领域建模
#### 说说概要设计

### 设计模式
#### 你项目中有使用哪些设计模式
#### 说说常用开源框架中设计模式使用分析
#### 说说你对设计原则的理解
#### 23种设计模式的设计理念
#### 设计模式之间的异同，例如策略模式与状态模式的区别
#### 设计模式之间的结合，例如策略模式+简单工厂模式的实践
#### 设计模式的性能，例如单例模式哪种性能更好。

### 业务工程
#### 你系统中的前后端分离是如何做的
#### 说说你的开发流程
#### 你和团队是如何沟通的
#### 你如何进行代码评审
#### 说说你对技术与业务的理解
#### 说说你在项目中经常遇到的 Exception
#### 说说你在项目中遇到感觉最难Bug，怎么解决的
#### 说说你在项目中遇到印象最深困难，怎么解决的
#### 你觉得你们项目还有哪些不足的地方
#### 你是否遇到过 CPU 100% ，如何排查与解决
#### 你是否遇到过 内存 OOM ，如何排查与解决
#### 说说你对敏捷开发的实践
#### 说说你对开发运维的实践
#### 介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色

### 软实力
#### 说说你的亮点
#### 说说你最近在看什么书
#### 说说你觉得最有意义的技术书籍
#### 工作之余做什么事情
#### 说说个人发展方向方面的思考
#### 说说你认为的服务端开发工程师应该具备哪些能力
#### 说说你认为的架构师是什么样的，架构师主要做什么
#### 说说你所理解的技术专家

## HR 篇

### 你为什么离开之前的公司
### 你为什么要进我们公司
### 说说职业规划
### 你如何看待加班问题
### 谈一谈你的一次失败经历
### 你觉得你最大的优点是什么
### 你觉得你最大的缺点是什么
### 你在工作之余做什么事情
### 你为什么认为你适合这个职位
### 你觉得自己那方面能力最急需提高
### 你来我们公司最希望得到什么
### 你希望从这份工作中获得什么
### 你对现在应聘的职位有什么了解
### 您还有什么想问的
### 你怎么看待自己的职涯
### 谈谈你的家庭情况
### 你有什么业余爱好
### 你计划在公司工作多久
